# 專案憲法：早餐店網路訂餐管理系統

## 版本資訊
- 版本: 1.0
- 創建日期: 2025-12-14
- 最後更新: 2025-12-14

---

## 1. 使用者體驗與設計原則 (UX/UI)

### 1.1 移動優先 (Mobile-First) [必須遵守]
**原則**: 所有界面設計必須以行動裝置體驗為主要考量。

**具體要求**:
- 所有頁面必須在螢幕寬度 320px-428px 之間完全可用
- 觸控目標最小尺寸為 44x44 像素（符合 iOS Human Interface Guidelines）
- 所有文字在移動裝置上可讀性良好（最小字體 14px）
- 表單輸入必須針對移動鍵盤優化（正確的 input type）

**測試標準**:
- 所有功能必須通過 Chrome DevTools Mobile 模擬測試
- Lighthouse Mobile Score 必須 ≥ 90 分

**參考文獻**: [13]

### 1.2 視覺品質 (Visual Quality) [必須遵守]
**原則**: 菜單項目必須使用高品質圖片展示，提高用戶購買意願。

**具體要求**:
- 菜單圖片最低解析度: 800x600 像素
- 圖片格式: WebP（優先）或 JPEG（後備）
- 圖片壓縮: 必須小於 200KB，同時保持視覺品質
- 所有圖片必須提供 alt 文字（無障礙性）

**參考文獻**: [11]

### 1.3 極簡化操作 (Minimum Action) [必須遵守]
**原則**: 任何核心流程所需的步驟必須少於 3 個。

**具體要求**:
- 從進入 App 到完成點餐: ≤ 3 次點擊
- 結帳流程: 選擇餐點 → 確認訂單 → 選擇支付（3 步驟）
- 重複訂購: 1 次點擊（從歷史記錄）

**測試標準**:
- 使用者測試中，80% 的測試者能在 30 秒內完成首次點餐

**參考文獻**: [10]

---

## 2. 程式碼質量與測試標準 (Code Quality & Testing)

### 2.1 TDD 遵守 (TDD Adherence) [必須遵守]
**原則**: 所有業務邏輯和 API 服務必須先定義測試，再編寫實現。

**具體要求**:
- 每個新功能必須先撰寫單元測試（Red Phase）
- 測試覆蓋率必須 ≥ 90%（使用 pytest-cov 測量）
- 所有 API 端點必須有對應的整合測試
- BDD 驗收測試必須使用 Gherkin 語法撰寫

**禁止行為**:
- ❌ 先寫程式碼，再補測試
- ❌ 跳過測試階段直接實作
- ❌ 使用 `pytest.skip()` 跳過失敗的測試

**測試框架**:
- 單元測試: pytest
- BDD 測試: behave (Gherkin)
- 前端測試: Jest + React Testing Library

**參考文獻**: [9]

### 2.2 類型安全與風格 (Type Safety) [強烈建議]
**原則**: 使用嚴格的類型檢查減少運行時錯誤。

**具體要求**:
- Python 後端: 使用 Type Hints（PEP 484）
- TypeScript 前端: 啟用 `strict` 模式
- 所有公開函數必須標註參數和返回值類型
- 使用 mypy (Python) 和 tsc (TypeScript) 進行靜態類型檢查

---

## 3. 性能與可靠性約束 (Performance and Reliability)

### 3.1 關鍵 API 延遲 (Critical API Latency) [必須遵守]
**原則**: 涉及訂單創建、支付或狀態更新的 API，響應時間必須 < 1500ms。

**具體要求**:
- **關鍵端點** (P95 延遲 < 1500ms):
  - `POST /api/orders` (創建訂單)
  - `PUT /api/orders/{id}/status` (更新狀態)
  - `POST /api/payments` (支付處理)

- **一般端點** (P95 延遲 < 3000ms):
  - `GET /api/menu` (獲取菜單)
  - `GET /api/orders/{id}` (查詢訂單)

**監控與測試**:
- 使用 Apache Bench 或 Locust 進行負載測試
- 在 CI/CD 中自動執行性能回歸測試
- 生產環境必須配置 APM 工具（如 New Relic、Datadog）

**參考文獻**: [2]

### 3.2 錯誤處理 (Error Handling) [必須遵守]
**原則**: 所有後端服務必須實現強健的錯誤處理機制。

**標準化錯誤格式** (JSON):
```json
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "人類可讀的錯誤訊息",
    "details": {
      "field": "具體的錯誤細節"
    },
    "timestamp": "2025-12-14T10:30:00Z"
  }
}
```

**錯誤碼範例**:
- `INVALID_INPUT`: 輸入驗證失敗
- `INSUFFICIENT_STOCK`: 庫存不足
- `PAYMENT_FAILED`: 支付失敗
- `UNAUTHORIZED`: 未授權存取

---

## 4. 安全與合規性 (Security and Compliance)

### 4.1 支付安全 (Payment Security) [必須遵守]
**原則**: 所有支付流程必須使用業界標準加密和安全協定。

**具體要求**:
- 所有 API 端點必須使用 HTTPS (TLS 1.3)
- 支付資料傳輸必須加密
- **禁止儲存**:
  - ❌ 完整信用卡號碼
  - ❌ CVV 安全碼
  - ❌ 信用卡到期日（除非經過 tokenization）

**合規性**:
- 遵循 PCI DSS Level 1 標準（如適用）
- 使用第三方支付閘道（如 Stripe、PayPal）處理敏感資料

**認證機制**:
- 使用 OAuth 2.0 + JWT 進行用戶認證
- Token 有效期: 1 小時（存取）/ 7 天（更新）
- 密碼必須使用 bcrypt 雜湊（cost factor ≥ 12）

**參考文獻**: [13]

### 4.2 API 文檔 (API Documentation) [必須遵守]
**原則**: 所有 RESTful API 端點必須生成規範的 OpenAPI/Swagger 文檔。

**具體要求**:
- 使用 OpenAPI 3.0 規範
- 每個端點必須包含:
  - 詳細的描述
  - 請求參數（含類型和範例）
  - 響應格式（含狀態碼和範例）
  - 錯誤響應範例
- API 文檔必須可透過 `/api/docs` 訪問
- 文檔必須隨程式碼更新（自動生成或手動維護）

**工具**:
- Flask: flask-swagger-ui
- 自動生成: swagger-autogen

---

## 5. 版本控制與發布流程 (Version Control)

### 5.1 Git 工作流程 [建議遵守]
**分支策略**:
- `main`: 生產環境代碼（受保護）
- `develop`: 開發整合分支
- `feature/*`: 功能分支
- `hotfix/*`: 緊急修復分支

**提交訊息格式**:
```
type(scope): subject

body (optional)

footer (optional)
```

**範例**:
```
feat(order): add order status tracking API

Implemented real-time order status updates using WebSocket.

Closes #42
```

### 5.2 CI/CD 流程 [必須遵守]
**自動化檢查** (每次 Pull Request):
1. 單元測試 (pytest)
2. BDD 測試 (behave)
3. 程式碼風格檢查 (flake8, black)
4. 類型檢查 (mypy)
5. 安全漏洞掃描 (bandit)
6. 性能測試（關鍵端點）

**發布流程**:
- 所有測試必須通過
- 程式碼審查必須獲得至少 1 位審核者批准
- Swagger 文檔必須更新

---

## 6. 文檔與知識管理

### 6.1 文檔要求 [必須遵守]
**必須維護的文檔**:
- 本憲法文件 (constitution.md)
- 功能規格 (spec.md)
- 技術計畫 (plan.md)
- API 文檔 (OpenAPI/Swagger)
- README.md（專案概述）

**文檔更新時機**:
- 新增重大功能時
- 修改核心架構時
- API 端點變更時

---

## 7. 審核與驗證

### 7.1 人類檢查點 (Human Checkpoints)
**強制審核點**:
1. 憲法創建/修改 → 技術主管批准
2. 規格定義 → 產品經理 + 技術主管批准
3. 技術計畫 → 資深工程師審核
4. 程式碼實作 → 同儕審核（Code Review）

### 7.2 自動化驗證
**CI 流程自動檢查**:
- ✅ 所有測試通過
- ✅ 覆蓋率 ≥ 90%
- ✅ 無安全漏洞
- ✅ 性能測試通過（關鍵 API < 1500ms）
- ✅ 文檔已更新

---

## 8. 例外處理機制

### 8.1 違反憲法的處理
**如果必須違反憲法原則**:
1. 必須在 tasks.md 中明確標註
2. 必須說明違反的理由和風險評估
3. 必須獲得技術主管和產品經理的明確批准
4. 必須在程式碼中添加 `# CONSTITUTION_EXCEPTION` 註解
5. 必須在下一個迭代中修正（技術債務追蹤）

---

## 簽署與生效

本憲法自 2025-12-14 起生效，適用於「早餐店網路訂餐管理系統」專案的所有開發活動。

**批准者**:
- 技術主管: [待簽署]
- 產品經理: [待簽署]
- 資深工程師: [待簽署]

**修訂歷史**:
- v1.0 (2025-12-14): 初始版本
```

---

#### 步驟 8.3：人類審核檢查清單

**審核要點**

| 檢查項目 | 是否完成 | 備註 |
|---------|---------|------|
| ✅ 所有原則都是可量化的（避免模糊描述） | ☐ | 例如：「性能好」→「延遲 < 1500ms」 |
| ✅ 包含具體的測試標準 | ☐ | 如何驗證是否符合原則 |
| ✅ 明確標註「必須遵守」vs「建議遵守」 | ☐ | 區分強制性與彈性原則 |
| ✅ 所有技術選型與 tech stack 一致 | ☐ | 例如：不要在 Python 專案中提到 Java |
| ✅ 包含例外處理機制 | ☐ | 現實中可能需要暫時違反原則 |
| ✅ 所有利益相關者已審核並批准 | ☐ | 技術主管、產品經理簽署 |

**常見錯誤與修正**

| ❌ 錯誤範例 | ✅ 正確範例 |
|----------|----------|
| "系統應該有良好的性能" | "關鍵 API 的 P95 延遲必須 < 1500ms" |
| "程式碼必須易於維護" | "所有公開函數必須包含類型提示和文檔字串" |
| "安全性很重要" | "所有 API 必須使用 HTTPS，密碼必須使用 bcrypt (cost ≥ 12)" |

**參考文獻**: [2], [21]

---

<a name="part9"></a>
### 9. 階段二：撰寫功能規格 (Specification)

#### 9.1 Gherkin 語法完整指南

**Gherkin 的核心結構**

| 關鍵字 | 用途 | 範例 |
|--------|------|------|
| **Feature** | 功能的高層次描述 | `Feature: 菜單瀏覽與購物車操作` |
| **Background** | 所有場景的共同前提條件 | `Background: Given 系統中存在菜單項目` |
| **Scenario** | 具體的業務規則或行為示例 | `Scenario: 成功將項目加入購物車` |
| **Given** | 描述系統的初始狀態 | `Given 購物車中包含總金額為 125 元的餐點` |
| **When** | 描述觸發事件或用戶互動 | `When 顧客將「經典蛋餅」加入購物車` |
| **Then** | 描述預期的可觀察結果 | `Then 購物車中應有 2 個獨立項目` |
| **And** | 連接多個連續步驟 | `And 購物車的總金額應為 80 元` |
| **But** | 連接多個連續步驟（否定） | `But 訂單不應被創建` |

**參考文獻**: [15], [16], [17]

---

**Gherkin 撰寫最佳實踐**

| ✅ 良好實踐 | ❌ 應避免 |
|----------|----------|
| 描述**業務行為**，而非技術實現 | 描述 UI 元素細節（如 button ID） |
| 使用**用戶語言**（顧客、管理員） | 使用技術術語（API、資料庫） |
| **可觀察的結果**（用戶看到什麼） | 內部狀態變化（記憶體、變數） |
| **一個場景測試一個規則** | 在一個場景中測試多個不相關的功能 |

**範例比較**

```gherkin
# ❌ 錯誤：過度關注技術細節
When 顧客點擊 ID 為 "add-to-cart-btn" 的按鈕
And 系統呼叫 addToCart() 函數
Then 資料庫中的 cart_items 表應新增一筆記錄

# ✅ 正確：關注業務行為
When 顧客將 "經典蛋餅" 加入購物車
Then 購物車中應顯示該餐點
And 購物車總金額應增加 35 元
```

**參考文獻**: [18], [19]

---

#### 步驟 9.1：啟動規格生成

**在 AI 助手中執行命令**

```
/speckit.specify Define the customer-facing ordering workflow covering menu browsing, cart management, checkout with multiple payment options, and order tracking. Include edge cases for out-of-stock items and payment failures. Use Gherkin format for all scenarios.
```

**命令解析**

| 參數 | 說明 |
|------|------|
| `customer-facing ordering workflow` | 指定範圍為客戶端功能 |
| `menu browsing, cart management, checkout, order tracking` | 明確列出核心功能 |
| `edge cases` | 要求包含邊界情況 |
| `out-of-stock items, payment failures` | 具體的邊界情況範例 |
| `Gherkin format` | 指定使用 Gherkin 語法 |

---

#### 步驟 9.2：完整規格範例 - spec.md

**文件開頭：專案概述**

```markdown
# 功能規格：早餐店網路訂餐管理系統

## 專案概述
- **專案名稱**: 早餐店網路訂餐管理系統
- **目標用戶**: 25-35 歲都市白領
- **核心價值**: 快速、便捷的早餐線上訂購體驗
- **技術棧**: Next.js (前端) + Flask (後端) + SQLite (資料庫)

## 規格版本
- **版本**: 1.0
- **創建日期**: 2025-12-14
- **最後更新**: 2025-12-14
- **狀態**: 草稿 / 審核中 / 已批准

---
```

**Feature 1: 菜單瀏覽與購物車操作**

```gherkin
# ================================================
# Feature 1: 菜單瀏覽與購物車操作
# ================================================

Feature: 菜單瀏覽與購物車操作
  作為一個忙碌的顧客
  我希望能夠快速瀏覽當前供應的早餐菜單
  將選定的餐點加入購物車
  並清楚查看總價
  以便在短時間內完成點餐

  Rule: 確保顧客能將多種餐點加入訂單
    Background:
      Given 系統中存在以下菜單項目：
        | item_id | name       | price | stock |
        | 001     | 經典蛋餅   | 35    | 50    |
        | 002     | 冰美式咖啡 | 45    | 30    |
        | 003     | 培根蛋三明治 | 55  | 20    |
      And 我尚未登入但已授權地理位置
      And 購物車為空

    # --------------------------------------------------
    # Scenario 1: 成功加入多個項目
    # --------------------------------------------------
    Scenario: 成功將多個項目加入空購物車
      When 顧客將 "經典蛋餅" (數量: 1) 加入購物車
      And 顧客將 "冰美式咖啡" (數量: 1) 加入購物車
      Then 購物車中應有 2 個獨立項目
      And 購物車的總金額應為 80 元
      And 顧客應看到一個顯示 "商品已加入" 的快顯通知
      And 購物車圖示應顯示數字 "2"

    # --------------------------------------------------
    # Scenario 2: 邊界情況 - 庫存不足
    # --------------------------------------------------
    Scenario: 嘗試將數量超過庫存的項目加入購物車
      Given "經典蛋餅" 的剩餘庫存為 10 份
      When 顧客嘗試將 "經典蛋餅" (數量: 15) 加入購物車
      Then 系統應顯示錯誤訊息 "無法加入：庫存不足，剩餘 10 份"
      And 購物車的總金額應保持為 0 元
      And 購物車應維持為空

    # --------------------------------------------------
    # Scenario 3: 修改購物車中的數量
    # --------------------------------------------------
    Scenario: 修改購物車中已存在項目的數量
      Given 購物車中已有 "經典蛋餅" (數量: 1)
      When 顧客將 "經典蛋餅" 的數量增加到 3
      Then 購物車中應仍然只有 1 個項目類型
      And "經典蛋餅" 的數量應顯示為 3
      And 購物車的總金額應為 105 元 (35 * 3)

    # --------------------------------------------------
    # Scenario 4: 從購物車移除項目
    # --------------------------------------------------
    Scenario: 從購物車移除單一項目
      Given 購物車中已有以下項目：
        | name       | quantity | subtotal |
        | 經典蛋餅   | 1        | 35       |
        | 冰美式咖啡 | 1        | 45       |
      And 購物車總金額為 80 元
      When 顧客從購物車移除 "冰美式咖啡"
      Then 購物車中應只剩 1 個項目
      And 購物車的總金額應更新為 35 元
      And 顧客應看到確認訊息 "已從購物車移除"
```

**Feature 2: 訂單結帳與支付處理**

```gherkin
# ================================================
# Feature 2: 訂單結帳與支付處理
# ================================================

Feature: 訂單結帳與支付處理
  作為一個顧客
  我希望能夠在結帳時選擇多種支付方式
  並在支付成功後立即收到訂單確認通知
  以確保訂單已送達餐廳

  Rule: 確保結帳流程支援多樣化的安全支付選項
    Background:
      Given 購物車中包含以下餐點：
        | name       | quantity | subtotal |
        | 經典蛋餅   | 2        | 70       |
        | 冰美式咖啡 | 1        | 45       |
      And 購物車總金額為 125 元（含運費 10 元）
      And 顧客已輸入有效的配送地址 "台北市信義區信義路五段 1 號"
      And 顧客已選擇 "預計 08:30 送達" 的時間
      And 支付閘道器 (Payment Gateway) 處於可接受交易的狀態

    # --------------------------------------------------
    # Scenario Outline: 使用不同支付方式成功結帳
    # --------------------------------------------------
    Scenario Outline: 使用不同支付方式成功結帳
      When 顧客選擇 <Payment_Method> 支付
      And 顧客提交訂單
      Then 支付閘道器應確認交易成功
      And 訂單應以「待處理 (Pending)」狀態創建
      And 訂單應包含以下資訊：
        | field              | value                       |
        | 訂單編號           | 自動生成（格式: ORD-YYYYMMDD-XXX） |
        | 總金額             | 125 元                      |
        | 支付方式           | <Payment_Method>            |
        | 配送地址           | 台北市信義區信義路五段 1 號 |
        | 預計送達時間       | 08:30                       |
      And 顧客應收到一封訂單確認郵件，包含訂單詳情
      And 顧客應被導向至訂單追蹤頁面

      Examples:
        | Payment_Method         |
        | 信用卡 (Visa/Mastercard) |
        | Apple Pay              |
        | LINE Pay               |
        | 現金 (Cash on Delivery)|

    # --------------------------------------------------
    # Scenario: 邊界情況 - 支付失敗
    # --------------------------------------------------
    Scenario: 處理支付失敗的情況
      Given 支付閘道器處於返回錯誤的狀態
      When 顧客選擇信用卡支付並提交訂單
      Then 系統應顯示錯誤訊息 "支付失敗，請檢查您的卡片資訊或嘗試其他支付方式"
      And 訂單不應被創建
      And 購物車的內容應保持不變
      And 顧客應仍然停留在結帳頁面
      And 系統應記錄支付失敗事件（用於後續分析）

    # --------------------------------------------------
    # Scenario: 邊界情況 - 配送地址無效
    # --------------------------------------------------
    Scenario: 配送地址不在服務範圍內
      Given 顧客輸入配送地址 "新竹市光復路二段 101 號"
      And 該地址不在系統的配送範圍內
      When 顧客嘗試提交訂單
      Then 系統應顯示錯誤訊息 "抱歉，該地址不在配送範圍內"
      And 系統應顯示最近的可配送地址建議
      And 訂單不應被創建
      And 顧客應被要求修改配送地址

    # --------------------------------------------------
    # Scenario: 訂單創建後的庫存扣減
    # --------------------------------------------------
    Scenario: 成功創建訂單後扣減庫存
      Given "經典蛋餅" 的當前庫存為 50 份
      When 顧客成功創建包含 2 份 "經典蛋餅" 的訂單
      Then "經典蛋餅" 的庫存應扣減為 48 份
      And 系統應記錄庫存變動日誌
      And 如果庫存低於 10 份，系統應發送補貨警告給管理員
```

**Feature 3: 訂單追蹤與狀態管理**

```gherkin
# ================================================
# Feature 3: 訂單追蹤與狀態管理（客戶端）
# ================================================

Feature: 訂單追蹤與狀態管理
  作為一個顧客
  我希望能夠即時追蹤我的訂單狀態
  並在狀態變更時收到通知
  以便掌握餐點準備進度

  Rule: 顧客必須能即時查看訂單狀態
    Background:
      Given 顧客已成功創建訂單 #ORD-20251214-001
      And 該訂單包含 2 份經典蛋餅
      And 訂單當前狀態為「待處理 (Pending)」

    # --------------------------------------------------
    # Scenario: 查看訂單詳情
    # --------------------------------------------------
    Scenario: 顧客查看訂單詳細資訊
      When 顧客在訂單追蹤頁面輸入訂單編號 #ORD-20251214-001
      Then 系統應顯示訂單的完整資訊：
        | field          | value                  |
        | 訂單編號       | #ORD-20251214-001      |
        | 訂單狀態       | 待處理                 |
        | 訂單時間       | 2025-12-14 07:45       |
        | 預計送達時間   | 2025-12-14 08:30       |
        | 配送地址       | 台北市信義區信義路五段 1 號 |
        | 總金額         | 125 元                 |
      And 系統應顯示訂單中的所有餐點項目

    # --------------------------------------------------
    # Scenario: 接收訂單狀態變更通知
    # --------------------------------------------------
    Scenario: 訂單狀態從「待處理」變更為「處理中」
      Given 管理員已接受訂單
      When 訂單狀態從「待處理」變更為「處理中」
      Then 顧客應收到推播通知：「您的訂單 #ORD-20251214-001 已開始製作」
      And 訂單追蹤頁面應自動更新狀態為「處理中」
      And 系統應顯示預計完成時間：「預計 08:20 完成」

    # --------------------------------------------------
    # Scenario: 邊界情況 - 訂單延遲
    # --------------------------------------------------
    Scenario: 訂單超過預計送達時間仍未完成
      Given 訂單的預計送達時間為 08:30
      And 當前時間為 08:35
      And 訂單狀態仍為「處理中」
      Then 系統應自動發送延遲通知給顧客：「抱歉，您的訂單延遲了，預計 08:45 送達」
      And 系統應記錄延遲事件（用於性能分析）
```

**Feature 4: 管理員訂單管理**

```gherkin
# ================================================
# Feature 4: 管理員訂單管理
# ================================================

Feature: 餐廳訂單管理後台
  作為餐廳管理員
  我希望能夠在後台清晰地查看所有待處理的訂單
  並能更新訂單狀態
  以便及時通知廚房開始製作，並向顧客提供準確的配送時間

  Rule: 管理員必須能夠有效地追蹤和更新訂單流程
    Background:
      Given 我已登入為具有訂單管理權限的管理員
      And 系統中存在以下訂單：
        | order_id           | status    | total | items          | created_at       |
        | #ORD-20251214-001  | Pending   | 125   | 經典蛋餅 x2    | 2025-12-14 07:45 |
        | #ORD-20251214-002  | In Progress | 80  | 冰美式咖啡 x1  | 2025-12-14 07:50 |

    # --------------------------------------------------
    # Scenario: 管理員接受並開始處理訂單
    # --------------------------------------------------
    Scenario: 管理員接受待處理訂單
      When 管理員在訂單 #ORD-20251214-001 頁面點擊「開始處理 (Start Processing)」按鈕
      Then 訂單狀態應更新為「處理中 (In Progress)」
      And 系統應記錄一個預計完成時間 (Estimated Completion Time)：當前時間 + 15 分鐘
      And 顧客端應用程式應立即收到狀態變更通知
      And 管理員應看到確認訊息：「訂單 #ORD-20251214-001 已開始處理」

    # --------------------------------------------------
    # Scenario: 管理員標記訂單為待配送
    # --------------------------------------------------
    Scenario: 管理員標記訂單為待配送
      Given 訂單 #ORD-20251214-001 的狀態為「處理中 (In Progress)」
      When 管理員在後台將訂單狀態更新為「待配送 (Ready for Delivery)」
      Then 系統應觸發配送人員的取餐通知
      And 顧客應收到包含預計送達時間的通知：「您的訂單已準備好，預計 08:30 送達」
      And 訂單列表中該訂單應移至「待配送」區域

    # --------------------------------------------------
    # Scenario: 邊界情況 - 訂單取消
    # --------------------------------------------------
    Scenario: 管理員取消訂單（緊急情況）
      Given 訂單 #ORD-20251214-001 的狀態為「待處理 (Pending)」
      When 管理員選擇「取消訂單」並輸入理由：「餐點材料不足」
      Then 訂單狀態應更新為「已取消 (Cancelled)」
      And 顧客應收到取消通知及全額退款資訊
      And 系統應自動觸發退款流程
      And 庫存應恢復（扣減的數量返還）
```

---

#### 步驟 9.3：人類審核檢查清單

**規格審核要點**

| 檢查項目 | 是否完成 | 備註 |
|---------|---------|------|
| ✅ 所有核心功能都已涵蓋 | ☐ | 菜單瀏覽、購物車、結帳、追蹤、管理員 |
| ✅ 每個 Feature 都有明確的 User Story | ☐ | 「作為...我希望...以便...」 |
| ✅ Background 定義了共同前提條件 | ☐ | 避免在每個 Scenario 中重複 |
| ✅ 每個 Scenario 測試單一業務規則 | ☐ | 避免過度複雜的場景 |
| ✅ 包含充足的邊界情況 (Edge Cases) | ☐ | 庫存不足、支付失敗、地址無效等 |
| ✅ 使用業務語言，避免技術細節 | ☐ | 不提及 API、資料庫、程式碼 |
| ✅ 所有 Then 步驟都是可觀察的結果 | ☐ | 用戶能看到或測試能驗證的 |
| ✅ 產品經理已審核並批准 | ☐ | 確保符合業務需求 |

---

#### 步驟 9.4：使用 /speckit.clarify 澄清模糊點

**當遇到規格不清晰時**

```
/speckit.clarify What should happen if a customer tries to checkout with an empty cart? Should the system allow placing orders for future dates (pre-ordering)?
```

**AI 會返回澄清建議**

```markdown
## 澄清要點

### 問題 1: 空購物車結帳
**建議行為**:
- 系統應禁止空購物車結帳
- 當顧客嘗試結帳時，顯示提示：「購物車為空，請先選擇餐點」
- 結帳按鈕在購物車為空時應為禁用狀態（灰色）

**需要確認**:
- 產品經理是否同意此行為？
- 是否需要提供「推薦餐點」快速加入功能？

### 問題 2: 預訂功能
**目前規格未涵蓋**:
- 是否允許顧客預訂明天或未來幾天的早餐？
- 如果允許，預訂的時間範圍是什麼（最多幾天）？
- 預訂訂單的取消政策是什麼？

**建議**:
- 如果是 MVP（最小可行產品），建議先不支援預訂，僅支援當天訂購
- 未來迭代中可新增預訂功能
```

**更新 spec.md**

將澄清後的決策加入規格：

```gherkin
# 新增的 Scenario
Scenario: 嘗試以空購物車結帳
  Given 購物車為空
  When 顧客嘗試點擊「前往結帳」按鈕
  Then「前往結帳」按鈕應為禁用狀態（不可點擊）
  And 系統應顯示提示訊息：「購物車為空，請先選擇餐點」
```

**參考文獻**: [3]

---

<a name="part10"></a>
### 10. 階段三：技術規劃 (Planning)

#### 10.1 技術規劃的目標

**從「What」到「How」的轉換**

```
spec.md (What) → plan.md (How)
業務需求       → 技術實現
```

**plan.md 的核心內容**

| 部分 | 內容 | 目的 |
|------|------|------|
| **概念性資料庫設計** | 實體、屬性、關係 | 定義資料結構 |
| **API 端點定義** | URL、方法、請求/響應格式 | 定義服務介面 |
| **技術架構** | 元件、層次、通訊協定 | 整體系統設計 |
| **依賴關係** | 第三方庫、服務、工具 | 技術棧實現 |
| **安全機制** | 認證、授權、加密 | 確保合規性 |

**參考文獻**: [5], [8]

---

#### 步驟 10.1：啟動技術規劃

**在 AI 助手中執行命令**

```
/speckit.plan Based on the specs and constitution, create a detailed technical plan using Next.js for the frontend and Flask for the backend API. Include complete database schema with relationships, all RESTful API endpoints with request/response formats, authentication strategy, and necessary payment integration mocks for both Admin and Customer features.
```

---

#### 步驟 10.2：完整技術計畫範例 - plan.md

```markdown
# 技術計畫：早餐店網路訂餐管理系統

## 文件資訊
- **版本**: 1.0
- **創建日期**: 2025-12-14
- **最後更新**: 2025-12-14
- **狀態**: 審核中
- **依據規格**: spec.md v1.0
- **依據憲法**: constitution.md v1.0